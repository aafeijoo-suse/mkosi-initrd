#!/usr/bin/env python

import ast
import functools
import os
import pathlib
import re
import subprocess
import sys

def dictify(f):
    def wrapper(*args, **kwargs):
        return dict(f(*args, **kwargs))
    return functools.update_wrapper(wrapper, f)

def unlink(path):
    try:
        os.unlink(path)
    except FileNotFoundError:
        pass

def buildroot():
    buildroot = os.getenv('BUILDROOT')
    buildroot = pathlib.Path(buildroot)
    return buildroot

def copy_in_modules(root, kver):
    file_filter = ['--nonmatching',
                   './lib/modules/*/bls.conf',      # a grub abomination with $grub_variables
                   './lib/modules/*/vmlinuz']

    path = pathlib.Path(sys.argv[0]).parent
    files = [path / f'kernel-core-{kver}.rpm']

    print(f'Setting up for kernel {kver}')

    for file in files:
        with subprocess.Popen(['rpm2cpio', file], stdout=subprocess.PIPE) as archive:
            subprocess.run(['cpio', '-i', '--make-directories', '--quiet', '-D', root, *file_filter],
                           stdin=archive.stdout,
                           check=True)

    subprocess.run(['depmod', '-a', '-w', '-b', root, kver], check=True)

@dictify
def read_os_release(root):
    try:
        f = open(root / 'etc/os-release')
    except FileNotFoundError:
        f = open(root / 'usr/lib/os-release')

    for line_number, line in enumerate(f, start=1):
        if not line.strip() or line.startswith('#'):
            continue
        if m := re.match(r'([A-Z][A-Z_0-9]+)=(.*)', line):
            name, val = m.groups()
            if val and val[0] in '"\'':
                val = ast.literal_eval(val)
            yield name, val
        else:
            print(f'Bad line {line_number}: {line}', file=sys.stderr)

def update_suffixed(items, name, fallback):
    value = items.get(name, fallback)
    if 'mkosi-initrd' in value:
        return
    items[name] = value + ' (mkosi-initrd)'

def make_initrd_release(root, out):
    os_release = read_os_release(root)

    # Replacing fields in the original dictionary should maintain the order
    update_suffixed(os_release, 'NAME', 'Linux')
    update_suffixed(os_release, 'PRETTY_NAME', 'Linux')
    os_release['VARIANT'] = 'mkosi-initrd'
    os_release['VARIANT_ID'] = 'mkosi-initrd'

    for name, value in os_release.items():
        if value:
            print(f'{name}={value!r}', file=out)

    print(f'Writing initrd-release with PRETTY_NAME={os_release["PRETTY_NAME"]!r}')

def write_initrd_release(root):
    output = root / 'etc/initrd-release'

    unlink(output)

    with open(output, 'wt') as out:
        make_initrd_release(root, out)

    unlink(root / 'etc/os-release')
    unlink(root / 'usr/lib/os-release')

    os.symlink('initrd-release', root / 'etc/os-release')

def make_init_symlink(root):
    init = root / 'init'
    unlink(init)
    os.symlink('usr/lib/systemd/systemd', init)
    print(f'Symlinked {init} → usr/lib/systemd/systemd')

def make_sysroot_dir(root):
    sysroot = root / 'sysroot'
    os.makedirs(sysroot, mode=0o755, exist_ok=True)
    print(f'Created {sysroot}')

def make_debug_shell_emergency(root):
    unit = root / 'etc/systemd/system/emergency.service'
    unlink(unit)
    os.symlink('debug-shell.service', unit)
    print(f'Symlinked {unit} → debug-shell.service')

def mask_units(root):
    units = [# https://github.com/karelzak/util-linux/pull/1313
             'fstrim.timer',

             # https://github.com/systemd/systemd/pull/19687
             'systemd-journal-flush.service',
             'systemd-tmpfiles-clean.timer',
             'systemd-random-seed.service',

             # systemd[1]: proc-sys-fs-binfmt_misc.automount: Got hangup/error on autofs pipe from kernel. Likely our automount point has been unmounted by someone or something else?
             # systemd[1]: proc-sys-fs-binfmt_misc.automount: Failed with result 'unmounted'.
             # systemd[1]: Mounting proc-sys-fs-binfmt_misc.mount...
             # systemd[1]: Mounted proc-sys-fs-binfmt_misc.mount.
             # systemd[1]: Starting systemd-binfmt.service...
             # systemd[1]: Finished systemd-binfmt.service.
             # systemd[1]: proc-sys-fs-binfmt_misc.automount: Path /proc/sys/fs/binfmt_misc is already a mount point, refusing start.
             # systemd[1]: Failed to set up automount proc-sys-fs-binfmt_misc.automount.
             # systemd[1]: proc-sys-fs-binfmt_misc.automount: Path /proc/sys/fs/binfmt_misc is already a mount point, refusing start.
             # systemd[1]: Failed to set up automount proc-sys-fs-binfmt_misc.automount.
             # systemd[1]: proc-sys-fs-binfmt_misc.automount: Path /proc/sys/fs/binfmt_misc is already a mount point, refusing start.
             # systemd[1]: Failed to set up automount proc-sys-fs-binfmt_misc.automount.
             # systemd[1]: Stopping systemd-binfmt.service...
             # systemd[1]: systemd-binfmt.service: Deactivated successfully.
             # systemd[1]: Stopped systemd-binfmt.service.
             'proc-sys-fs-binfmt_misc.automount',
             'proc-sys-fs-binfmt_misc.mount',

             # Dracut installs a rule which sets OPTIONS+="db_persist" on all dm devices [1]
             # (According to codesearch.debian.net, it is the only user of db_persist.)
             # Without this, all dm units end up with SYSTEMD_READY=0 and systemd things the
             # device units are missing. The system boots fine, but an attempt to call
             # daemon-reexec or daemon-reload ends with anything that can be stopped or unmounted
             # being purged.
             #
             # In systemd, we always have cleaned the database on switch-root, since the initial
             # addition of the initrd-* units in cf843477946451fabf9b5d17eec8ec81515057b6. But
             # that seems pointless, since initrds need to match the kernel version and are
             # generally used with the main system in the main version or slightly newer. And
             # for important devices, db_persist is set. So we end up destroying some of the
             # state, but not all. Let's just skip the cleanup altogether, and rely on the rules
             # being idempotent to that we end up in the correct state.
             #
             # [1] https://raw.githubusercontent.com/dracutdevs/dracut/2d83bce21bfc874b29c1fb99e8fabb843f038725/modules.d/90dm/11-dm.rules
             'initrd-udevadm-cleanup-db.service']

    subprocess.run(['systemctl', f'--root={root}', 'mask', *units], check=True)

if __name__ == '__main__':
    if sys.argv[1] != 'final':
        exit(0)

    root = buildroot()

    # kver = os.uname().release
    kver = '5.12.5-300.fc34.x86_64'
    copy_in_modules(root, kver)

    write_initrd_release(root)

    make_init_symlink(root)
    make_sysroot_dir(root)

    mask_units(root)

    make_debug_shell_emergency(root)
